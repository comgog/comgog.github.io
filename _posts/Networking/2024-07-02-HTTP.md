---
title:  "HTTP 기초"
excerpt: "HTTP 개요..?, HTTP 종류 알아보기 "

categories:
  - Networking
tags:
  - [Networking, Protocol]


toc: true
toc_sticky: true
 
date: 2024-07-02
last_modified_at: 2024-07-02
---

- HTTP는 **클라이언트와 서버**가 서로 통신하는 방법을 표준화하는 **TCP/IP기반 응용 계층 통신 프로토콜**
- HTTP는 요청과 응답을 얻기위해 TCP/IP에 의존
- HTTP는 기본적으로 80번 포트
- HTTPS는 443번 포트 사용

- **HTTP/0.9**
	- 최초로 문서화된 HTTP 버전
	- 클라이언트가 GET요청을 보내면 (`GET /index.html`)
	- 서버에서 HTML을 전송 - 끝

### HTTP / 1.0 - 1996
- HTML만 전송할 수 있던 0.9버전과 달리 이미지, 비디오등 다른 형식의 파일도 전송할 수 있게 됨
- 더 많은 메소드가 추가됨 (HEAD, POST등..)
- 요청 및 응답에 해더가 추가됨
- 그 외에도 상태 코드, 인증, 캐싱, 문자열 지원등이 추가됨

- **클라이언트의 요청 예시**
	```
	GET / HTTP/1.0
	Host: cs.fyi
	User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
	Accept: */*
	```
	- 클라이언트는 요청과 함께 **개인 정보, 필요한 응답 유형**등을 함께 보냄

- **서버의 응답 예시**
	```
	HTTP/1.0 200 OK 
	Content-Type: text/plain
	Content-Length: 137582
	Expires: Thu, 05 Dec 1997 16:00:00 GMT
	Last-Modified: Wed, 5 August 1996 15:55:28 GMT
	Server: Apache 0.84
	
	(response body)
	(connection closed)
	```
	- 첫 번째 줄의 HTTP/1.0 뒤에 숫자는 상태 코드이며, 그 다음엔 이유 문구가 있음
	- 이 버전의 HTTP에서 헤더는 여전히 ASCII로 인코딩된 상태지만, response body 부분은 이미지, 비디오, HTML, 일반 텍스트등 모든 유형이 가능함

- **단점**
	- 한 번의 연결에 여러개의 요청을 할 수 없음.
	- 즉 클라이언트가 서버에서 필요한 항목의 수만큼 새 연결을 해야함.
	- 5개의 이미지, 3개의 CSS, 2개의 JS파일이 필요한 웹사이트라면 10번의 개별 연결을 필요로 하게 되는데, 이는 각각의 **3-way Handshaking**으로 이어져 심각한 성능 저하가 발생함

####  3-way Handshaking
- TCP/IP 프로토콜을 이용하여 통신할 때, 전송을 보장하기 위해 **사전에 세션을 수립하는 과정**
	 1. Client -> Server : TCP SYN
	 2. Server -> Client : TCP SYN ACK
	 3. Client -> Server : TCP ACK![Pasted image 20240702144600](https://github.com/comgog/first-HTML/assets/102729927/6acec587-8327-4cbb-ac81-028d1a6b481b)
		출처)  https://cs.fyi/guide/http-in-depth

### HTTP / 1.1 - 1997
- 개선 사항
	- 새로운 메서드 추가 (PUT, PATCH, Option, DELETE)
	- Hostname Identification이 헤더에 필요
	- **지속적인 연결이 가능해짐** <- 기본적으로 연결을 끊지 않도록 바뀜
		- 연결을 닫으려면 Connection: Close 헤더를 사용
	- **파이프라이닝에 대한 지원**
		- Pipelining : 클라이언트가 하나의 TCP 연결을 통해 서버의 응답을 기다리지 않고, 여러개의 요청을 순차적으로 보내는 기능
		- 서버에서는 요청이 들어온 순서와 동일하게 응답을 보내야 함.
		- 클라이언트는 요청에 대한 모든 응답이 들어올 때 까지 새로운 요청을 보낼 수 없음.
		- [!!!] 파이프라이닝이 원할하게 진행되려면 클라이언트가 한 요청에 대한 응답의 종료점을 알아야한다 (요청 - 응답을 매칭시키기 위해)
			- 이를 위해 Content-Length 헤더를 사용, 헤더는 응답의 종료지점을 식별할 수 있게 하며, 서버의 다음 응답을 대기시킬 수 있음.
	- **청크 전송(Chunked Transfers)**
		- 서버에서 데이터를 전송할 때 동적 데이터를 전송하여 데이터의 길이를 알 수 없을 때 사용.
		- 데이터를 조각(청크)으로 나누어 전송하고, 전송시 청크의 길이를 추가
		- 마지막 청크를 전송시 Content-Length를 0으로 설정된 청크를 보냄
		- 청크 전송임을 알리기 위해 Transfer-Encoding: Chunked를 헤더에 포함
	- 다이제스트 및 프록시 인증
	- 캐싱, 바이트 범위, 향상된 압축 지원, 새로운 상태 코드 등등..

- 단점
	- 지속되는 연결만을 항상 한 개만 가질 수 있음.
	- 파이프라인을 지원하지만, 파이프라인에서 느리거나 무거운 요청이 뒤에 있는 요청이 지연되는 Head-of-Line Blocking(HOL Blocking) 문제가 발생 
		- 요청 a, b, c를 보냈을 때 a의 처리가 늦어져 b, c가 a보다 먼저 처리되더라도 클라이언트에게 전송할 수 없음.
		- 단점을 해결하기 위해 인코딩된 이미지 사용, 단일 휴머전트 CSS/JS사용, 도메인 샤딩 같은 기법들을 구현하기 시작

### SPDY - 2009
- 약자 아님
- 구글에서 만듬
- 대역폭을 계속 늘리더라도 성능향상이 더뎌지는 시점이 생김, 하지만 **지연시간을 단축**하는 것은 지속적인 성능 향상이 가능!
- 다중화, 압축, 우선순위 지정등으로 지연시간을 단축함
- HTTP/2가  대부분 SPDY에서 영감을 받음

### HTTP/2 - 2015
- 개선 사항
	- **텍스트 대신 이진법 사용**
		- 이진 프로토콜을 사용하여 구문 분석이 쉬워졌지만, 사람이 읽을 수 없음
		- HTTP/2는 프레임과 스트림으로 구성 (프레임의 모임 -> 스트림)
		- 모든 요청과 응답에는 **고유한 스트림ID**가 부여됨
		- 각 프레임에는 자신이 속한 스트림ID가 있고, 공통 헤더가 존재
		- 요청을 홀수 스트림ID, 응답은 짝수 스트림ID를 사용함
		- 특정 스트림을 중지시킬수 있는 RST_STREAM이라는 특수 프레임 존재

	- **다중화** - 단일 연결을 통한 여러 비동기 HTTP 요청
		- 요청 및 응답에 프레임과 스트림을 사용하며, **비동기적으로 전송**됨
			- 클라이언트와 서버 모두 처리되는 순서대로(비동기) 전송
		- 클라이언트가 스트림ID를 통해 식별하므로 HOF Blocking문제가 해결됨

	- **HPACK을 이용한 헤더 압축**
		- 동일한 클라이언트가 반복적으로 서버에 엑세스할 때, 헤더에 있는 중복되는 데이터가 반복적으로 전송됨
		- 헤더를 압축하여 지연시간을 단축

	- **서버 푸시** - 단일 요청에 대한 여러 응답
		- 서버에서 클라이언트의 요청전에 필요로 하는 리소스를 클라이언트에게 푸시
		- 웹 페이지 로딩 성능을 개선하기 위해 도입
		- 클라이언트가 index.html 요청 시
			- 서버가 이후에 클라이언트가 css, js파일을 요청할 것이라고 예측하여 해당 파일을 클라이언트에게 푸시함
			- 클라이언트는 푸시받은 파일을 캐시에 저장하여 나중에 사용함
		- 푸시할 것임을 클라이언트에게 알리는 특수 프레임인 push frame을 사용

	- **요청 우선 순위**
		- 클라이언트는 우선 순위 프레임을 전송하여 스트림의 우선 순위를 언제든지 변경 가능
		- 서버는 요청을 비동기적으로 처리하기 때문에 우선 순위가 반영되지 않는다, 따라서 우선순위가 할당된 경우 우선순위에 따라 리소스 할당량을 정한다.

	- **보안**
		- TLS를 통한 보안이 의무는 아니지만 대부분의 공급업체는 HTTP/2를 TLS를 통해 사용될 때만 지원함
		- 따라서 TLS를 통해 구현할 때의 몇가지 요구사항이 정해짐
			- TLS 1.2 버전 이상을 사용
			- 특정 수준이상의 최소 키 크기 사용 등..

