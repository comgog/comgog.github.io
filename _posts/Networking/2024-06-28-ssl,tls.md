---
title:  "SSL과 TLS"
excerpt: "SSL(TLS) 기초와 간단한 동작과정.."

categories:
  - Networking
tags:
  - [Protocol, SSL/TLS]


toc: true
toc_sticky: true
 
date: 2024-06-28
last_modified_at: 2024-06-28
---

### SSL (Secure Sockets Layer)?
- **암호화 기반 인터넷 보안 프로토콜**
- 인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 개발
- 현재 사용중인 TLS 암호화의 전신이다.
- SSL/TLS를 사용하는 웹사이트의 URL은 HTTPS를 쓴다

### 어떻게 동작하죠?
- SSL은 개인정보 보호를 제공하기 위해 웹에서 전송되는 데이터를 암호화함
	- 기존 웹 상의 데이터는 텍스트 형태로 전송되었음.
	- 비밀번호, 카드번호등 중요한 정보를 가로채기만 하면 누구나 읽을 수 있었음.
- 그로인해 중간에서 가로채더라도 해독하기 어려운 암호만 보게 됨
- SSL은 두 통신 장치 사이에 **핸드셰이크**라는 **인증 프로세스**를 시작하여 각 장치의 ID를 확인.
- 또한 데이터 무결성을 제공하기 위해 데이터에 **디지털 서명**을 함으로써 조작되지 않았음을 확인한다.
- 또한 공격자가 전송 중인 데이터를 조작하지 못하게 막는 일과 접속한 사이트가 신뢰할 만한 사이트인지 알려주는 역할도 수행

### SSL과 TLS?
- TLS(Transport Layer Security)는 SSL의 다음 버전으로 IETF에서 개발, SSL을 개발했던 Netscape가 개발에 참여하지 않게 되어 소유권 변경을 나타내기 위해 이름을 변경
- SSL은 1996년 SSL 3.0 이후 업데이트되지 않았으며 앞으로 사라질 것으로 여겨짐
- SSL엔 여러 취약점들이 발견되어, 최신 웹 브라우저는 대부분 사용하지 않음
- 현재는 TLS이 업계 표준으로 자리잡음, 현재 SSL이라고 불리는 것들도 사실은 대부분 TLS 암호화임

### SSL 인증서
- SSL(TLS)은 SSL(TLS) 인증서가 있는 웹사이트만 실행할 수 있음.
- **SSL(TLS)인증서는 신원을 확인하는 용도**로 사용되며, 웹사이트나 애플리케이션 서버가 웹에 저장하고 표시함.
- SSL(TLS)인증서에서 가장 중요한 부분은 웹사이트의 **공개 키와 인증서를 발급한 CA 정보**이다.
- 사용자는 이 **공개키를 사용하여 데이터를 암호화**하여 전송함
- 웹 서버에서는 공개하지 않고 보관 중인 **개인키를 통해 복호화**를 진행
- 

### CA (Certificate Authority)
- 클라이언트가 **접속한 서버가 접속하려던 서버가 맞는지 보장**해주는 역할을 하는 민간기업. Root Certificate라고도 불림
- 크롬, 엣지, 사파리등의 브라우저에는 내부적으로 **CA목록과 CA의 공개키가 내장**되어 있음. 이 목록에 포함되어야 **공인된 CA**가 될 수 있다.
- 개발이나 사적으로 SSL 암호화를 사용하기 위해 직접 CA의 역할을 수행할 수 있지만 공인된 CA가 아니기 때문에 브라우저가 경고를 출력한다.

### 작동 메커니즘

#### 1. handshake
1. 클라이언트가 서버에 접속한다. 이 단계를  Client Hello라고 한다
	- 이 단계에서 클라이언트는 서버에게 정보를 제공
		- **클라이언트 측에서 생성한 랜덤데이터**
		- 클라이언트가 지원하는 **암호화 방식들**
		- **세션아이디**(세션 재활용을 위해)
2. 서버는 Client Hello에 대한 응답으로 Server Hello를 하게된다
	- 서버가 클라이언트에 제공하는 정보
		- **서버측에서 생성한 랜덤 데이터**
		- 서버가 선택한 **암호화 방식**
			- Client Hello에서 받은 암호화 방식들 중 하나를 선택
		- **인증서**
3. 웹 브라우저는 해당 인증서를 발급한 CA가 내장 CA 목록에 있는지 조회
4. 공인된 CA임이 확인되면 내장되어있던 공개키를 통해 인증서를 복호화
	- 위 과정을 통해 인증서가 서버의 신뢰성을 보장한다
5. 클라이언트는 서버와 클라이언트에서 생성한 **각각의 랜덤 데이터를 조합하여 pre master secret이라는 키를 생성**한다(이 키는 개인키로 사용되므로 노출되면 안됨)
6. SSL인증서로 부터 받은 서버의 공개키로 pre master secret을 암호화하여 서버로 전달
7. 서버와 클라이언트는 **각자의 랜덤 값과 pre master secret값을 사용해 동일한 master secret값을 생성**
8. **master secret으로 session key를 생성**
9. 클라이언트와 서버가 서로에게 핸드쉐이크 종료를 알림
#### 2. 세션
- session key를 이용하여 데이터를 주고 받음.
- "Change Cipher Spec" 메시지를 서버에 보내 이후의 통신이 암호화 될 것임을 알림
- 클라이언트는 "Finished" 메시지를 보낸 후, 세션 키를 사용한 첫 번째 암호화된 메시지를 서버에 보냄
- 서버도 "Change Cipher Spec" 메시지를 보내고 "Finished" 메시지를 클라이언트에 보냄
#### 3. 세션 종료
- 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알림
- 세션키를 폐기
